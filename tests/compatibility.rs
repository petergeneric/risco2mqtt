//! Cross-language compatibility tests.
//!
//! Reads JSON fixture files generated by the JavaScript test suite
//! (`test/generate-vectors.js`) and verifies that the Rust implementation
//! produces identical outputs.

use risco_lan_bridge::crypto::RiscoCrypt;
use serde::Deserialize;
use std::fs;
use std::path::Path;

fn fixtures_dir() -> &'static Path {
    Path::new("test/fixtures")
}

// ─── Pseudo-buffer ──────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct PseudoBufferVector {
    panel_id: u16,
    buffer: Vec<u8>,
}

#[test]
fn test_pseudo_buffer_compatibility() {
    let data = fs::read_to_string(fixtures_dir().join("pseudo_buffer.json"))
        .expect("Run `node test/generate-vectors.js` first");
    let vectors: Vec<PseudoBufferVector> = serde_json::from_str(&data).unwrap();

    for v in &vectors {
        let buf = RiscoCrypt::create_pseudo_buffer(v.panel_id);
        assert_eq!(
            buf.to_vec(),
            v.buffer,
            "Pseudo buffer mismatch for panel_id {}",
            v.panel_id
        );
    }
    eprintln!("pseudo_buffer: {} vectors passed", vectors.len());
}

// ─── CRC ────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct CrcVector {
    label: String,
    input_bytes: Vec<u8>,
    expected_crc: String,
}

#[test]
fn test_crc_compatibility() {
    let data = fs::read_to_string(fixtures_dir().join("crc.json"))
        .expect("Run `node test/generate-vectors.js` first");
    let vectors: Vec<CrcVector> = serde_json::from_str(&data).unwrap();

    for v in &vectors {
        let crc = RiscoCrypt::compute_crc(&v.input_bytes);
        assert_eq!(
            crc, v.expected_crc,
            "CRC mismatch for '{}': expected {}, got {}",
            v.label, v.expected_crc, crc
        );
    }
    eprintln!("crc: {} vectors passed", vectors.len());
}

// ─── Encode ─────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct EncodeVector {
    panel_id: u16,
    crypt_enabled: bool,
    command: String,
    cmd_id: String,
    force_crypt: Option<bool>,
    encoded_bytes: Vec<u8>,
}

#[test]
fn test_encode_compatibility() {
    let data = fs::read_to_string(fixtures_dir().join("encode.json"))
        .expect("Run `node test/generate-vectors.js` first");
    let vectors: Vec<EncodeVector> = serde_json::from_str(&data).unwrap();

    for v in &vectors {
        let mut crypt = RiscoCrypt::new(v.panel_id);
        crypt.set_crypt_enabled(v.crypt_enabled);
        let encoded = crypt.encode_command(&v.command, &v.cmd_id, v.force_crypt);
        assert_eq!(
            encoded, v.encoded_bytes,
            "Encode mismatch for panel_id={}, cmd='{}', cmd_id='{}', force_crypt={:?}\n  expected: {:?}\n  got:      {:?}",
            v.panel_id, v.command, v.cmd_id, v.force_crypt, v.encoded_bytes, encoded
        );
    }
    eprintln!("encode: {} vectors passed", vectors.len());
}

// ─── Decode ─────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct DecodeVector {
    label: String,
    panel_id: u16,
    crypt_enabled: bool,
    input_bytes: Vec<u8>,
    expected_cmd_id: String,
    expected_command: String,
    expected_crc_valid: bool,
}

#[test]
fn test_decode_compatibility() {
    let data = fs::read_to_string(fixtures_dir().join("decode.json"))
        .expect("Run `node test/generate-vectors.js` first");
    let vectors: Vec<DecodeVector> = serde_json::from_str(&data).unwrap();

    for v in &vectors {
        let mut crypt = RiscoCrypt::new(v.panel_id);
        crypt.set_crypt_enabled(v.crypt_enabled);
        let decoded = crypt.decode_message(&v.input_bytes);

        // For wrong-key decodes, JS Buffer.from(bytes,'utf-8').toString('utf-8')
        // and Rust String::from_utf8_lossy may differ on invalid UTF-8 bytes.
        // Only check cmd_id and crc_valid for wrong-key cases.
        let is_wrong_key = v.label.starts_with("wrong_key");

        if !is_wrong_key {
            assert_eq!(
                decoded.cmd_id, v.expected_cmd_id,
                "'{}': cmd_id mismatch: expected '{}', got '{}'",
                v.label, v.expected_cmd_id, decoded.cmd_id
            );
            assert_eq!(
                decoded.command, v.expected_command,
                "'{}': command mismatch: expected '{}', got '{}'",
                v.label, v.expected_command, decoded.command
            );
        }

        assert_eq!(
            decoded.crc_valid, v.expected_crc_valid,
            "'{}': crc_valid mismatch: expected {}, got {}",
            v.label, v.expected_crc_valid, decoded.crc_valid
        );
    }
    eprintln!("decode: {} vectors passed", vectors.len());
}

// ─── DLE edge cases ─────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct DleEdgeCaseVector {
    panel_id: u16,
    encoded_bytes: Vec<u8>,
    has_dle_stx: bool,
    has_dle_etx: bool,
    has_dle_dle: bool,
}

#[test]
fn test_dle_edge_cases_compatibility() {
    let data = fs::read_to_string(fixtures_dir().join("dle_edge_cases.json"))
        .expect("Run `node test/generate-vectors.js` first");
    let vectors: Vec<DleEdgeCaseVector> = serde_json::from_str(&data).unwrap();

    let mut dle_stx_count = 0;
    let mut dle_etx_count = 0;
    let mut dle_dle_count = 0;

    for v in &vectors {
        // Verify encode produces identical bytes
        let mut enc = RiscoCrypt::new(v.panel_id);
        enc.set_crypt_enabled(true);
        let encoded = enc.encode_command("CUSTLST?", "01", None);
        assert_eq!(
            encoded, v.encoded_bytes,
            "DLE encode mismatch for panel_id {}",
            v.panel_id
        );

        // Verify decode roundtrip
        let mut dec = RiscoCrypt::new(v.panel_id);
        dec.set_crypt_enabled(true);
        let decoded = dec.decode_message(&v.encoded_bytes);
        assert_eq!(
            decoded.cmd_id, "01",
            "DLE roundtrip cmd_id mismatch for panel_id {}",
            v.panel_id
        );
        assert_eq!(
            decoded.command, "CUSTLST?",
            "DLE roundtrip command mismatch for panel_id {}",
            v.panel_id
        );
        assert!(
            decoded.crc_valid,
            "DLE roundtrip CRC failed for panel_id {}",
            v.panel_id
        );

        if v.has_dle_stx {
            dle_stx_count += 1;
        }
        if v.has_dle_etx {
            dle_etx_count += 1;
        }
        if v.has_dle_dle {
            dle_dle_count += 1;
        }
    }

    eprintln!(
        "dle_edge_cases: {} vectors passed (DLE+STX: {}, DLE+ETX: {}, DLE+DLE: {})",
        vectors.len(),
        dle_stx_count,
        dle_etx_count,
        dle_dle_count
    );
}
